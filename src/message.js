"use strict";
module.exports = Message;

/**
 * Constructs a new message instance.
 *
 * This method should be called from your custom constructors, i.e. `Message.call(this, properties)`.
 * @classdesc Abstract runtime message.
 * @extends {Object}
 * @constructor
 * @param {Object.<string,*>} [properties] Properties to set
 * @abstract
 * @see {@link Class.create}
 */
function Message(properties) {
    if (properties) {
        var keys = Object.keys(properties);
        for (var i = 0; i < keys.length; ++i)
            this[keys[i]] = properties[keys[i]];
    }
}

/** @alias Message.prototype */
var MessagePrototype = Message.prototype;

/**
 * Converts this message to a JSON object.
 * @param {Object.<string,*>} [options] Conversion options
 * @param {boolean} [options.fieldsOnly=false] Converts only properties that reference a field
 * @param {*} [options.long] Long conversion type. Only relevant with a long library.
 * Valid values are `String` and `Number` (the global types).
 * Defaults to a possibly unsafe number without, and a `Long` with a long library.
 * @param {*} [options.enum=Number] Enum value conversion type.
 * Valid values are `String` and `Number` (the global types).
 * Defaults to the numeric ids.
 * @param {*} [options.bytes] Bytes value conversion type.
 * Valid values are `Array` and `String` (the global types).
 * Defaults to return the underlying buffer type.
 * @param {boolean} [options.defaults=false] Also sets default values on the resulting object
 * @returns {Object.<string,*>} JSON object
 */
MessagePrototype.asJSON = function asJSON(options) {
    if (!options)
        options = {};
    var fields = this.$type.fields,
        json   = {};
    var keys = Object.keys(options.defaults ? fields : this);
    for (var i = 0, key; i < keys.length; ++i) {
        var field = fields[key = keys[i]],
            value = this[key];
        if (field) {
            if (field.repeated) {
                if (value && (value.length || options.defaults)) {
                    json[key] = [];
                    for (var j = 0, l = value.length; j < l; ++j)
                        json[key].push(field.jsonConvert(value[j], options));
                }
            } else
                json[key] = field.jsonConvert(value, options);
        } else if (!options.fieldsOnly)
            json[key] = value;
    }
    return json;
};

/**
 * Reference to the reflected type.
 * @name Message.$type
 * @type {Type}
 * @readonly
 */

/**
 * Reference to the reflected type.
 * @name Message#$type
 * @type {Type}
 * @readonly
 */

/**
 * Encodes a message of this type.
 * @param {Message|Object} message Message to encode
 * @param {Writer} [writer] Writer to use
 * @returns {Writer} Writer
 */
Message.encode = function encode(message, writer) {
    return this.$type.encode(message, writer);
};

/**
 * Encodes a message of this type preceeded by its length as a varint.
 * @param {Message|Object} message Message to encode
 * @param {Writer} [writer] Writer to use
 * @returns {Writer} Writer
 */
Message.encodeDelimited = function encodeDelimited(message, writer) {
    return this.$type.encodeDelimited(message, writer);
};

/**
 * Decodes a message of this type.
 * @name Message.decode
 * @function
 * @param {Reader|Uint8Array} readerOrBuffer Reader or buffer to decode
 * @returns {Message} Decoded message
 */
Message.decode = function decode(readerOrBuffer) {
    return this.$type.decode(readerOrBuffer);
};

/**
 * Decodes a message of this type preceeded by its length as a varint.
 * @name Message.decodeDelimited
 * @function
 * @param {Reader|Uint8Array} readerOrBuffer Reader or buffer to decode
 * @returns {Message} Decoded message
 */
Message.decodeDelimited = function decodeDelimited(readerOrBuffer) {
    return this.$type.decodeDelimited(readerOrBuffer);
};

/**
 * Verifies a message of this type.
 * @name Message.verify
 * @function
 * @param {Message|Object} message Message or plain object to verify
 * @returns {?string} `null` if valid, otherwise the reason why it is not
 */
Message.verify = function verify(message) {
    return this.$type.verify(message);
};
